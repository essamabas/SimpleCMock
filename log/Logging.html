<!DOCTYPE html>
<head>
<style>
table { width: 100% }
th { font:bold 10pt Tahoma; }
td { font:normal 10pt Tahoma; }
h1 {font:normal 11pt Tahoma;}
</style>
</head>
<body>
<h1>Mon Apr 25 16:53:59 CEST 2016</h1>
<table border="0" cellpadding="5" cellspacing="3">
<tr align="left">
	<th style="width:10%">Loglevel</th>
	<th style="width:15%">Time</th>
	<th style="width:75%">Log Message</th>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:53</td>
	<td>-----------------------------------------------------</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:53</td>
	<td>--------------------getAllPreprocessorStatements--------------------------------</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>preprocessor - #ifndef l2s_calc_crc8_MOCK</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>-----------------------------------------------------</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - static const GT_U8 crc8table[256] =
{
   /* [0x00..0x0F] */    0,  29,  58,  39, 116, 105,  78,  83, 232, 245, 210, 207, 156, 129, 166, 187,
   /* [0x10..0x1F] */  205, 208, 247, 234, 185, 164, 131, 158,  37,  56,  31,   2,  81,  76, 107, 118,
   /* [0x20..0x2F] */  135, 154, 189, 160, 243, 238, 201, 212, 111, 114,  85,  72,  27,   6,  33,  60,
   /* [0x30..0x3F] */   74,  87, 112, 109,  62,  35,   4,  25, 162, 191, 152, 133, 214, 203, 236, 241,
   /* [0x40..0x4F] */   19,  14,  41,  52, 103, 122,  93,  64, 251, 230, 193, 220, 143, 146, 181, 168,
   /* [0x50..0x5F] */  222, 195, 228, 249, 170, 183, 144, 141,  54,  43,  12,  17,  66,  95, 120, 101,
   /* [0x60..0x6F] */  148, 137, 174, 179, 224, 253, 218, 199, 124,  97,  70,  91,   8,  21,  50,  47,
   /* [0x70..0x7F] */   89,  68,  99, 126,  45,  48,  23,  10, 177, 172, 139, 150, 197, 216, 255, 226,
   /* [0x80..0x8F] */   38,  59,  28,   1,  82,  79, 104, 117, 206, 211, 244, 233, 186, 167, 128, 157,
   /* [0x90..0x9F] */  235, 246, 209, 204, 159, 130, 165, 184,   3,  30,  57,  36, 119, 106,  77,  80,
   /* [0xA0..0xAF] */  161, 188, 155, 134, 213, 200, 239, 242,  73,  84, 115, 110,  61,  32,   7,  26,
   /* [0xB0..0xBF] */  108, 113,  86,  75,  24,   5,  34,  63, 132, 153, 190, 163, 240, 237, 202, 215,
   /* [0xC0..0xCF] */   53,  40,  15,  18,  65,  92, 123, 102, 221, 192, 231, 250, 169, 180, 147, 142,
   /* [0xD0..0xDF] */  248, 229, 194, 223, 140, 145, 182, 171,  16,  13,  42,  55, 100, 121,  94,  67,
   /* [0xE0..0xEF] */  178, 175, 136, 149, 198, 219, 252, 225,  90,  71,  96, 125,  46,  51,  20,   9,
   /* [0xF0..0xFF] */  127,  98,  69,  88,  11,  22,  49,  44, 151, 138, 173, 176, 227, 254, 217, 196
};</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - static unsigned short crc16table[256] = /* CRC lookup table polynomial 0xA001 */
{
    0x0000, 0xa001, 0xe003, 0x4002, 0x6007, 0xc006, 0x8004, 0x2005,
    0xc00e, 0x600f, 0x200d, 0x800c, 0xa009, 0x0008, 0x400a, 0xe00b,
    0x201d, 0x801c, 0xc01e, 0x601f, 0x401a, 0xe01b, 0xa019, 0x0018,
    0xe013, 0x4012, 0x0010, 0xa011, 0x8014, 0x2015, 0x6017, 0xc016,
    0x403a, 0xe03b, 0xa039, 0x0038, 0x203d, 0x803c, 0xc03e, 0x603f,
    0x8034, 0x2035, 0x6037, 0xc036, 0xe033, 0x4032, 0x0030, 0xa031,
    0x6027, 0xc026, 0x8024, 0x2025, 0x0020, 0xa021, 0xe023, 0x4022,
    0xa029, 0x0028, 0x402a, 0xe02b, 0xc02e, 0x602f, 0x202d, 0x802c,
    0x8074, 0x2075, 0x6077, 0xc076, 0xe073, 0x4072, 0x0070, 0xa071,
    0x407a, 0xe07b, 0xa079, 0x0078, 0x207d, 0x807c, 0xc07e, 0x607f,
    0xa069, 0x0068, 0x406a, 0xe06b, 0xc06e, 0x606f, 0x206d, 0x806c,
    0x6067, 0xc066, 0x8064, 0x2065, 0x0060, 0xa061, 0xe063, 0x4062,
    0xc04e, 0x604f, 0x204d, 0x804c, 0xa049, 0x0048, 0x404a, 0xe04b,
    0x0040, 0xa041, 0xe043, 0x4042, 0x6047, 0xc046, 0x8044, 0x2045,
    0xe053, 0x4052, 0x0050, 0xa051, 0x8054, 0x2055, 0x6057, 0xc056,
    0x205d, 0x805c, 0xc05e, 0x605f, 0x405a, 0xe05b, 0xa059, 0x0058,
    0xa0e9, 0x00e8, 0x40ea, 0xe0eb, 0xc0ee, 0x60ef, 0x20ed, 0x80ec,
    0x60e7, 0xc0e6, 0x80e4, 0x20e5, 0x00e0, 0xa0e1, 0xe0e3, 0x40e2,
    0x80f4, 0x20f5, 0x60f7, 0xc0f6, 0xe0f3, 0x40f2, 0x00f0, 0xa0f1,
    0x40fa, 0xe0fb, 0xa0f9, 0x00f8, 0x20fd, 0x80fc, 0xc0fe, 0x60ff,
    0xe0d3, 0x40d2, 0x00d0, 0xa0d1, 0x80d4, 0x20d5, 0x60d7, 0xc0d6,
    0x20dd, 0x80dc, 0xc0de, 0x60df, 0x40da, 0xe0db, 0xa0d9, 0x00d8,
    0xc0ce, 0x60cf, 0x20cd, 0x80cc, 0xa0c9, 0x00c8, 0x40ca, 0xe0cb,
    0x00c0, 0xa0c1, 0xe0c3, 0x40c2, 0x60c7, 0xc0c6, 0x80c4, 0x20c5,
    0x209d, 0x809c, 0xc09e, 0x609f, 0x409a, 0xe09b, 0xa099, 0x0098,
    0xe093, 0x4092, 0x0090, 0xa091, 0x8094, 0x2095, 0x6097, 0xc096,
    0x0080, 0xa081, 0xe083, 0x4082, 0x6087, 0xc086, 0x8084, 0x2085,
    0xc08e, 0x608f, 0x208d, 0x808c, 0xa089, 0x0088, 0x408a, 0xe08b,
    0x60a7, 0xc0a6, 0x80a4, 0x20a5, 0x00a0, 0xa0a1, 0xe0a3, 0x40a2,
    0xa0a9, 0x00a8, 0x40aa, 0xe0ab, 0xc0ae, 0x60af, 0x20ad, 0x80ac,
    0x40ba, 0xe0bb, 0xa0b9, 0x00b8, 0x20bd, 0x80bc, 0xc0be, 0x60bf,
    0x80b4, 0x20b5, 0x60b7, 0xc0b6, 0xe0b3, 0x40b2, 0x00b0, 0xa0b1
};</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U8 l2s_calc_crc8(GT_U8* start, GT_U32 size)
{
    GT_U32 i;
    GT_U8 crc = 0xFFU;

    for(i = 0; i < size; i++)
    {
        /* polyspace<RTE: IDP : Not a defect : Justify with annotations > The address-of operator ‘&’ will never return a null pointer and the size-of-operator limits the access to the memory */
        crc = crc8table[crc ^ start[i]];
    }
    /* invert result */
    crc = crc ^ 0xFFU;

    return crc;
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U16 l2s_calc_crc16(GT_U8* start, GT_U32 size)
{
    GT_U32 i;
    GT_U16 crc = 0x0001;
    GT_U8 index;

    for(i = 0; i < size; i++)
    {
        /* polyspace<RTE: IDP : Not a defect : Justify with annotations > The address-of operator ‘&’ will never return a null pointer and the size-of-operator limits the access to the memory */
        index = (GT_U8)(crc >> 8) ^ start[i];
        crc = crc16table[index] ^ (GT_U16)(crc << 8);
    }
    /* invert result */
    //crc = crc ^ 0xFFFF;

    return crc;
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_abs_s16_sat(GT_S16 in_value_abs_sat)
{
    /* Define local variables */
    GT_S16 out_value_abs_sat;

    /* Input < 0 */
    if (in_value_abs_sat < 0)
    {
        /* Input <= S16_MIN */
        if (in_value_abs_sat <= GT_S16_MIN)
        {
            /* Set output S16_MAX */
            out_value_abs_sat = (GT_S16)GT_S16_MAX;
        }
        else
        {
            /* Set output to input * (-1) */
            out_value_abs_sat = (-1) * in_value_abs_sat;
        }
    }
    else
    {
        /* Set output to input */
        out_value_abs_sat = in_value_abs_sat;
    }

    /* Return output value */
    return(out_value_abs_sat);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_s16_sat(GT_S32 in_value)
{
    /* Define local variables */
    GT_S16 out_value_sat;

    /* Input > S16 max */
    if (in_value > GT_S16_MAX)
    {
        /* Set output to GT_S16_MAX */
        out_value_sat = GT_S16_MAX;
    }
    else
    {
        /* Input < S16_MIN */
        if (in_value < GT_S16_MIN)
        {
            /* Set output to GT_S16_MIN */
            out_value_sat = (GT_S16)GT_S16_MIN;
        }
        else
        {
            /* Set output to input */
            out_value_sat = (GT_S16)in_value;
        }
    }

    /* Return output value */
    return(out_value_sat);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_s16_add_s16_s16_sat(GT_S16 in_value1, GT_S16 in_value2)
{
    /* Define local variables \n\n*/
    GT_S16 ret_value;
  
    /* Calculate sum of input 1 and input 2 */
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    ret_value = in_value1 + in_value2;

    /* Input 1 < 0 AND
       input 2 < 0 AND
       calculated sum >= 0? */
    if ( (in_value1 < 0) && (in_value2 < 0) && (ret_value >= 0) )
    {
        /* Underflow detected:
           Set output to data type S16 minimum */
        ret_value = (GT_S16)GT_S16_MIN;
    }
    else
    {
        /* Input 1 > 0 AND
           input 2 > 0 AND
           calculated sum <= 0? */
        if ( (in_value1 > 0) && (in_value2 > 0) && (ret_value <= 0) )
        {
        /* Overflow detected:
           Set output to data type S16 maximum */
            ret_value = (GT_S16)GT_S16_MAX;
        }
    }

    /* Return result */
    return(ret_value);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S32 l2s_lib_s32_add_s32_s32_sat(GT_S32 in_value1, GT_S32 in_value2)
{
    /* Define local variables \n\n*/
    GT_S32 ret_value;
  
    /* Calculate sum of input 1 and input 2 */
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    ret_value = in_value1 + in_value2;

    /* Input 1 < 0 AND
       input 2 < 0 AND
       calculated sum >= 0? */
    if ( (in_value1 < 0) && (in_value2 < 0) && (ret_value >= 0) )
    {
        /* Underflow detected:
           Set output to data type S32 minimum */
        ret_value = (GT_S32)GT_S32_MIN;
    }
    else
    {
        /* Input 1 > 0 AND
           input 2 > 0 AND
           calculated sum <= 0? */
        if ( (in_value1 > 0) && (in_value2 > 0) && (ret_value <= 0) )
        {
            /* Overflow detected:
               Set output to data type S16 maximum */
            ret_value = (GT_S32)GT_S32_MAX;
        }
    }

    /* Return result */
    return(ret_value);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_s16_sub_s16_s16_sat(GT_S16 in_value1, GT_S16 in_value2)
{
    /* Define local variables \n\n*/
    GT_S16 ret_value;

    /* Calculate difference of input 1 and input 2 */
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    ret_value = in_value1 - in_value2;

    /* Input 1 < 0 AND
       input 2 > 0 AND
       calculated difference >= 0? */
    if ( (in_value1 < 0) && (in_value2 > 0) && (ret_value >= 0) )
    {
        /* Underflow detected:
           Set output to data type S16 minimum */
        ret_value = (GT_S16)GT_S16_MIN;
    }
    else
    {
        /* Input 1 >= 0 AND
           input 2 < 0 AND
           calculated difference <= 0? */
        if ( (in_value1 >= 0) && (in_value2 < 0) && (ret_value <= 0) )
        {
            /* Overflow detected:
               Set output to data type S16 maximum */
            ret_value = (GT_S16)GT_S16_MAX;
        }
    }

    /* Return result */
    return(ret_value);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U16 l2s_lib_u16_add_u16_u16_sat(GT_U16 in_value1, GT_U16 in_value2)
{
    /* Define local variables \n\n*/
    GT_U16 tmp_result;
  
    /* Calculate sum of input 1 and input 2 */
    tmp_result = in_value1 + in_value2;

    /*input 1 > result*/
    if (in_value1 > tmp_result)
    {
        /* overflow detected:
           Set output to data type U16 maximum */
        tmp_result = (GT_U16)GT_U16_MAX;
    }

    /* Return result */
    return(tmp_result);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U16 l2s_lib_u16_sub_u16_u16_sat(GT_U16 in_value1, GT_U16 in_value2)
{
    /* Define local variables \n\n*/
    GT_U16 tmp_result;
  
    /* Calculate sum of input 1 and input 2 */
    tmp_result = in_value1 - in_value2;

    /* input 1 < input 2*/
    if ((in_value1 < in_value2))
    {
        /* underflow detected:
           Set output to data type U16 minmum */
        tmp_result = (GT_U16)GT_U16_MIN;
    }

    /* Return result */
    return(tmp_result);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U32 l2s_lib_div_u32u32(GT_U32 z, GT_U32 n)
{
    /* Define local variables \n\n*/
    GT_U32 result;
    GT_U32 rest;

    /* Divisor is zero? */
    if(n == 0U)
    {
        /* Set output to max value */
        result = GT_U32_MAX;
    }
    else
    {
        result = z/n;
        rest = z%n;
        
        if((rest > 2147483647U) || (rest<<1) >= n)
        {
            /* round to next higher value */
            result++;
        }
    }

    /* Return result*/
    return(result);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S32 l2s_lib_div_s32s32(GT_S32 z, GT_S32 n)
{
  GT_S32 result;
  GT_U32 abs_z, abs_n, rest;
  GT_BOOL pos;
  if(n == 0)
  {
      if(z >= 0)
      {
          result = GT_S32_MAX;
      }
      else
      {
          result = GT_S32_MIN;
      }
  }
  else
  {
      abs_z = (GT_U32)(z >=0) ? z : (-z);
      abs_n = (GT_U32)(n >=0) ? n : (-n);

      result = abs_z/abs_n;
      rest = abs_z%abs_n;

      if((rest<<1) >= abs_n)
      {
          /* aufrunden */
          result++;
      }

      pos =((n<0) == (z<0));
      
      if(!pos)
      {
        result = -result; 
      }
  }
  return result;
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S32 l2s_abs_s32(GT_S32 i)
{
    GT_S32 res;

    if (i == GT_S32_MIN)
    {
        res = GT_S32_MAX;
    }
    else
    {
        res = i < 0 ? -i : i;
    }

    return res;
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_U8 l2s_lib_idx_brkpt_srch(const volatile GT_S16 *x_list, GT_S8 nr, GT_S16 x_in)
{
  /*define locals*/
  GT_S8  i;
  GT_U8  tmp_brkpt;

  /*make amount of breakpoints to index*/
  nr--;
    
  /*_OSCA: that was meant-> for(i=nr; ((x_in < x_list[i]) && (i >=0)); i--)*/
  /*_OSCA:                  {*/
  /*_OSCA:                  }*/
  
/*result in i is next breakpoint no. below real input x, lowest value is -1*/  
  for (i=nr; i >=0; i--)
  {
    /*real input >= breakpoint?*/
    /* polyspace<RTE: IDP : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    if(x_in >= x_list[i])
    {
        /*breakpoint found,
          leave loop*/
        break;
    }
  }
  	  
  /* x below lowest breakpoint?*/
  if(i< 0)          
  { 
    /*set to lowest breakpoint nr =0*/
    tmp_brkpt= 0;
  }
  else
  {
    /*deliver breakpoint index*/
    tmp_brkpt= (GT_U8)(i); 
  }
  
  /*return index*/
  return(tmp_brkpt);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - l2s_lib_ipol_brkpt_type l2s_lib_ipol_brkpt_srch(const volatile GT_S16 *x_list, GT_S8 nr, GT_S16 x_in)
{
  /*define locals*/
  GT_S8  i;
  GT_S16 tmp_u;
  GT_S16 tmp_d;
  GT_S16 tmp_r; /*_OSCA: ratio [S16 | En14 | - ]*/
  
  /*define local breakpoint structure/n*/
  l2s_lib_ipol_brkpt_type result; 
  
  /*breakpoint search routine for x- or y- input*/
  
  /*make amount of break points to index*/
  nr--;

  
  /*_OSCA: that was meant-> for(i=nr; ((x_in < x_list[i]) && (i >=0)); i--)*/
  /*_OSCA:                  {*/
  /*_OSCA:                  }*/

  /*result in i is next breakpoint no. below real input x, lowest value is -1*/
  for (i=nr; i >=0; i--)
  {
    /*real input >= breakpoint?*/
    if(x_in >= x_list[i])
    {
        /*breakpoint found,
          leave loop*/
        break;
    }
  }
  	  
  /* is x below lowest breakpoint?*/
  if(i< 0)          
  { 
    /*set index i to lowest breakpoint nr =0 and set*/
    /*ratio r to 0 for map/function calculation*/
    i = 0 ;
    tmp_r = 0 ;  
  }                
  else 
  { 
    /*is x above highest breakpoint?*/
    if(i == nr)    
  	{ 
  	  /*set ratio r to 0 for map/function calculation*/
  	  tmp_r = 0;       
  	}
    else  		      
    {                                                                         
      /*here: x_in is in between an intervall X_i and X_(i+1)/n*/
      /*u = x_in - X_i*/
      /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
      tmp_u = x_in - x_list[i];
      
      /*d = X_(i+1) - X_i*/
      /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */      
      tmp_d = x_list[i+1] - x_list[i];
      
      /*r = (u<<14)/d*/
      /* polyspace<RTE: OVFL, ZDV : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */      
      tmp_r = (GT_S16)((((GT_S32)(tmp_u))*(1*GT_BIN_EN14))/((GT_S32)(tmp_d)));  
    };                                                                        
   }
  
  /*load interval ratio and index into return structure*/
  result.ival_ratio = tmp_r;
  result.idx = i;

  return result;    
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_ipol_dim2_S16_S16(l2s_lib_ipol_dim2_type *ptr_dim2, GT_S16 x_in)
{
    /*define locals*/
    GT_S8  tmp_idx; 
    GT_S16 tmp_r;   /*ratio [S16 | En14 | - ] /n/n*/ 
    GT_S16 y;       
    
    /*local breakpoint structure/n/n*/
    l2s_lib_ipol_brkpt_type tmp_brkpt; 
    
    /*breakpoint evaluation in x-direction/n*/
    tmp_brkpt= l2s_lib_ipol_brkpt_srch(ptr_dim2->x_list, ptr_dim2->no_brk_pts, x_in);
    
    /*load interval ratio and index no. into internal values/n*/
    tmp_idx= tmp_brkpt.idx; 
    tmp_r= tmp_brkpt.ival_ratio;
    
    
    /*calculate output value y = function(x) with the equation
    y= (Y(i) * (1-ratio)) + (Y(i+1) * ratio)*/
    
                                  /*_OSCA:         Y(i) * (1-ratio)         */
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */                              
    y= (GT_S16)(((((GT_S32)(ptr_dim2->y_list[tmp_idx]))*((GT_S32)(((GT_S32)(1*GT_BIN_EN14))-(GT_S32)(tmp_r))))
    
                                  /*_OSCA:         (Y(i+1) * ratio)       */
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */                              
                 +(((GT_S32)(ptr_dim2->y_list[tmp_idx+1]))* ((GT_S32)(tmp_r))))/(1*GT_BIN_EN14)); 
    	                                       
    /*return y*/
    return y ;
    
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_rolav_S16_S16(GT_S16 input, GT_S16 old_result, GT_S16 filt_coef)
{
    /*define locals*/
    GT_S16 tmp;
    GT_S16 result;
    GT_S32 tmp_residual; /*the residual [S32 | En14 | - ]*/
    
     
    /*calculate the residual*/
    /*residual=               (input - old_result)            *        (1 - filt_coef)*/
    
    /*_OSCA: original statement before MISRA check*/
    /*tmp_residual= (((GT_S32)(input)) - ((GT_S32)(old_result)))*((GT_S32)(((GT_S16)(1*GT_BIN_EN14))-filt_coef));*/
    
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    tmp_residual= ((((GT_S32)(input)) - ((GT_S32)(old_result))) * (((GT_S32)(1*GT_BIN_EN14))-((GT_S32)(filt_coef))));

    
    /*bring it back to BIN_EN0*/
                  /*_OSCA:        >>14*/
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */              
    tmp= (GT_S16)(tmp_residual/(GT_BIN_EN14));
    
    /*round a negative value towards 0*/
    if((tmp_residual<0)&&((((GT_U32)(tmp_residual))&0x00003fffU)!= 0U))
    {
     tmp++;
    }
    
    /* polyspace<RTE: OVFL : Not a defect : Justify with annotations > see l2s_polyspace_orange_items_gd2.doc */
    result= input - tmp;
    
  return(result);    
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_mul_s16_s16_sr13_sat(GT_S16 in_value1, GT_S16 in_value2)
{
  /* Define local variables \n\n*/
  GT_S32 tmp_prod;
  GT_S16 tmp_return_val;

  /* Calculate product of input 1 and input 2 with cast to S32 \n\n*/
  tmp_prod = ((GT_S32)in_value1 * (GT_S32)in_value2);

  /* Take scaling of En14 into account */
  tmp_prod = tmp_prod / GT_BIN_EN13;

  /* Calculated product >
     S16 data type maximum? */
  if (tmp_prod > GT_S16_MAX)
  {
    /* Set output to S16 data type maximum */
    tmp_return_val = (GT_S16)GT_S16_MAX;
  }
  else
  {
    /* Calculated product <=
       S16 data type minimum? */
    if ( tmp_prod <= ((GT_S32)GT_S16_MIN) )
    {
      /* Set output to data type S16 minimum */
      tmp_return_val = (GT_S16)GT_S16_MIN;
    }
    else
    {
      /* Cast calculated product
         to S16 data type */
      tmp_return_val = (GT_S16)tmp_prod;
    }
  }

  /* Return result */
  return (tmp_return_val);
}</td>
</tr>
<tr>
	<td>INFO</td>
	<td>Apr 25,2016 16:54</td>
	<td>declaration - GT_S16 l2s_lib_maxS16S16S16(GT_S16 a, GT_S16 b)
{
	return a > b ? a : b;
}</td>
</tr>
